# Alogrithm Practice
1. 자료구조
2. 그리디
3. 구현
    3-1. 완전 탐색: 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
    3-2. 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계식 차례대로 직접 수행해야하는 문제 유형 
4. DFS/BFS
5. 정렬
6. 이진탐색
7. 다이나믹 프로그래밍
8. 최단 경로
9. 그래프
------------------------------------------------------------------------------------------
# Complexity 
복잡도(Complexity)는 알고리즘의 성능을 나타내는 척도.
1. 시간 복잡도: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는지를 의미 -> 알고리즘을 위해 필요한 연산에 횟수
2. 공간 복잡도: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지 의미 -> 알고리즘을 위해 필요한 메모리의 양
*동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 좋은 알고리즘이다.
-대체로 코딩 테스트에서는 128 ± 512 MB로 메모리를 제한하는데 알고리즘 문제 중 때로는 수백만 개 이상의 데이터를 처리해야 하는 문제가 출제됨
데이터의 개수(리스트의 길이) | 메모리 사용량
1000 | 약 4kb
1,000,000 | 약 4MB
10,000,000 | 약 40MB
<Big-O 표기법> # 예를 들어 제한 시간이 1초인 문제는 연산 횟수가 3000만이 넘는 알고리즘은 사용하면 안된다. 
1. O(1) 상수 시간: 문제를 해결하는데 오직 한 단계만 처리 -> 1초 최대 연산 횟수
2. O(logN) 로그 시간: 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듦 -> 1초 최대 연산 횟수 10억
3. O(N) 직선적 시간: 문제를 해결하기 위한 단계의 수와 입력 값 n이 1:1 관계를 가진다. -> 1초 최대 연산 횟수 1000±2000만
4. O(NlogN) 선형 로그형 : 문제를 해결하기 위한 단계의 수가 N * (log2N) 번만큼의 수행시간을 가진다 -> 1초 최대 연산 횟수 100만
5. O(N**2) 2차 시간: 문제를 해결하기 위한 단계의 수는 입력 값 n의 제곱 -> 1초 최대 연산 횟수 3000~5000
6. O(N**3) -> 1초 최대 연산 횟수 200~300
7. O(2**n) 지수 시간: 문제를 해결하기 위한 단계의 수는 주어진 상수 값 C 의 n 제곱 -> 1초 최대 연산 횟수 20~25 
------------------------------------------------------------------------------------------
# sys.stdin.readline() 사용법
1. 한개의 정수를 입력 받을 때
   import sys
   a = int(sys.stdin.readline())
2. 정해진 개수의 정수를 한줄에 입력받을 때
    import sys
   a,b,c = map(int, sys.stdin.readline().split())
3. 임의의 개수의 정수를 한줄에 입력받아 리스트에 저장할 때
   import sys
    data = list(map(int,sys.stdin.readline().split())